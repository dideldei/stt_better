"""
Fokus-TUI - Reactive State-Bindung for Phase 3.2

UI reagiert ausschlie√ülich auf State-√Ñnderungen √ºber reactive Felder.
Kein direkter Widget-Zugriff aus Logik, kein refresh().
"""

import subprocess
import threading
import time
from pathlib import Path
from typing import Optional
import numpy as np
from textual.app import App, ComposeResult
from textual.reactive import reactive
from textual.widgets import Static
from textual.containers import Container, Horizontal, Vertical, VerticalScroll
from textual.message import Message

from app.state_machine import StateMachine
from domain.states import AppState
from domain.events import (
    AppEvent,
    DoctorCompleted,
    FullSTTDone,
    FullSTTFail,
    KeyF2Pressed,
    KeyF8Pressed,
    KeyF9Pressed,
    KeyF10Pressed,
)
from services.fake_background_service import FakeBackgroundService
from services.snippet_tracker_service import SnippetTrackerService
from services.recording_service import RecordingService
from services.doctor_service import DoctorService, DoctorCheckResult
from services.stt_service import STTService, STTServiceResult, FullTranscriptionResult
from util.logging_setup import get_logger
from util.config_loader import load_config


class FakeBackgroundEvent(Message):
    """
    Event for fake background updates (Ticket 5.1).
    
    Generated by background thread, processed in UI thread.
    """
    def __init__(self, message: str, thread_id: int) -> None:
        self.message = message
        self.thread_id = thread_id
        super().__init__()


class MicLevelUpdated(Message):
    """
    Message for real mic level updates.
    Emitted at ‚â§10 Hz from RecordingService; handler updates level_bar.
    """
    def __init__(self, level: float) -> None:
        self.level = level
        super().__init__()


class SnippetReadyMessage(Message):
    """
    Message for snippet ready event (Ticket 7.1 & 8.2).
    
    Generated by background thread when snippet threshold is reached,
    processed in UI thread.
    
    Ticket 8.2: Added error_hint for STT failure handling.
    """
    def __init__(
        self,
        snippet_text: str,
        quality: str,
        thread_id: int,
        error_hint: Optional[str] = None
    ) -> None:
        self.snippet_text = snippet_text
        self.quality = quality
        self.thread_id = thread_id
        self.error_hint = error_hint
        super().__init__()


class FokusTUI(App):
    """
    Fokus-TUI with reactive state binding.
    
    UI reagiert ausschlie√ülich auf State-√Ñnderungen √ºber reactive Felder.
    Alle Widget-Updates erfolgen √ºber watch-Handler.
    """
    
    # Reactive Felder gem√§√ü UNIFIED.md 6.2
    app_state: reactive[str] = reactive("INIT")
    header_mic: reactive[str] = reactive("OK")
    header_model: reactive[str] = reactive("OK")
    rec_timer: reactive[str] = reactive("")
    status_recording: reactive[str] = reactive("AUS")
    status_transcript: reactive[str] = reactive("‚Äî")
    level_bar: reactive[str] = reactive("Pegel: [          ]")
    warnings: reactive[str] = reactive("Warnungen: (keine)")
    snippet_text: reactive[str] = reactive("(leer)")
    snippet_quality: reactive[str] = reactive("‚Äî")
    transcript_text: reactive[str] = reactive("(noch nicht verf√ºgbar)")
    last_error_code: reactive[str] = reactive("")
    last_error_hint: reactive[str] = reactive("")
    
    CSS_PATH = "app.tcss"
    
    BINDINGS = [
        ("escape", "quit", "Quit"),
        ("f9", "key_f9", "Rec/Pause/Resume"),
        ("f10", "key_f10", "Stop"),
        ("f6", "key_f6", "Copy"),
        ("f8", "key_f8", "Redo"),
        ("f2", "key_f2", "Doctor"),
        ("f3", "key_f3", "Start Fake Background (5.1)"),
    ]
    
    def __init__(self) -> None:
        """Initialize FokusTUI with state machine."""
        super().__init__()
        self.state_machine = StateMachine(initial_state=AppState.INIT)
        self.logger = get_logger(__name__)
        self.ui_thread_id = threading.get_native_id()
        # Initial reactive fields based on INIT state (no old_state for initial)
        self._update_reactive_fields_from_state(AppState.INIT, AppState.INIT)
        
        # Load config for snippet threshold (Ticket 7.1)
        self.config = load_config()
        
        # Fake background service for Ticket 5.1
        self.fake_background_service: FakeBackgroundService | None = None
        
        # Snippet tracker service for Ticket 7.1
        self.snippet_tracker_service: SnippetTrackerService | None = None
        
        # Recording service (real mic) for Snippet and Full-STT
        self.recording_service: RecordingService | None = None
        
        # Doctor service for Ticket 3.5.1
        # Get project root (go up from ui/ to project root)
        project_root = Path(__file__).parent.parent
        self.doctor_service = DoctorService(project_root)
        
        # STT service for Ticket 8.1
        self.stt_service: STTService | None = None
        
        # Temporary storage for doctor results (mic/model status)
        self._doctor_result_mic_ok = True
        self._doctor_result_model_ok = True
    
    def compose(self) -> ComposeResult:
        """Create the static UI layout"""
        # Header - Use single Static widget for entire status line (simpler, more reliable)
        # Will be updated as a whole by watch handlers
        yield Container(
            Static("STT-Diktat-Agent | ... | Mic: ... | Model: ...", id="header_status"),
            Static("F9 Rec/Pause/Resume | F10 Stop | F6 Copy | Esc Quit | F2 Doctor", id="header_keybindings"),
            id="header_container"
        )
        
        # STATUS section
        yield Container(
            Static("STATUS", classes="section_title"),
            Static("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),
            Static("Aufnahme: ‚Äî | Transkript: ‚Äî", id="status_line"),
            id="status_container"
        )
        
        # LIVE FEEDBACK and EARLY SNIPPET (side by side)
        yield Horizontal(
            Container(
                Static("LIVE FEEDBACK", classes="section_title"),
                Static("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),
                Static("Pegel: [          ]", id="level_bar"),
                Static("Warnungen: (keine)", id="warnings"),
                id="live_feedback_container"
            ),
            Container(
                Static("EARLY SNIPPET", classes="section_title"),
                Static("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),
                Static("(leer)", classes="empty_text", id="snippet_text"),
                id="snippet_container"
            ),
            id="feedback_snippet_container"
        )
        
        # TRANSKRIPT section
        yield Container(
            Static("TRANSKRIPT", classes="section_title"),
            Static("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),
            VerticalScroll(
                Static("(noch nicht verf√ºgbar)", classes="empty_text", id="transcript_box"),
                id="transcript_scroll",
            ),
            Static(""),
            Static("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),
            Static("F8 Redo with better model | F6 Copy", id="footer_actions"),
            id="transcript_container"
        )
    
    def on_mount(self) -> None:
        """Initialize UI with current reactive field values after widgets are mounted."""
        # Update header status line to sync with current reactive values
        self._update_header_status()
        # Trigger watch handlers for other reactive fields
        self.status_recording = self.status_recording
        self.status_transcript = self.status_transcript
        self.level_bar = self.level_bar
        self.warnings = self.warnings
        self.snippet_text = self.snippet_text
        self.snippet_quality = self.snippet_quality
        self.transcript_text = self.transcript_text
        # status_line: watches from __init__ fail (No screens on stack); on_mount self-assign does not re-trigger (same value). Sync explicitly.
        self._sync_status_line()
        
        # Log UI thread ID for Ticket 5.1 verification
        self.logger.info(f"[UI-Thread {self.ui_thread_id}] FokusTUI mounted")
        
        # Real auto-Doctor for Ticket 3.5.1
        # Per UNIFIED.md 5.2: App starts in INIT ‚Üí Auto-Doctor/Preflight runs ‚Üí OK ‚Üí READY
        if self.state_machine.current_state == AppState.INIT:
            self.logger.info("Running auto-Doctor (Ticket 3.5.1)")
            self.notify("üîç Doctor checks starting...", severity="information", timeout=2)
            self._run_doctor_checks()
    
    def _run_doctor_checks(self) -> None:
        """
        Run doctor checks asynchronously (Ticket 3.5.1).
        
        Doctor service runs in background thread and posts results
        back to UI thread via callback.
        """
        def handle_doctor_result(result: DoctorCheckResult) -> None:
            """
            Handle doctor check result in UI thread.
            
            This callback is called from the doctor thread, so we use
            call_from_thread to safely post events to UI thread.
            """
            # Create DoctorCompleted event
            doctor_event = DoctorCompleted(
                success=result.success,
                error_code=result.error_code,
                error_hint=result.error_hint,
            )
            
            # Store mic and model status for updating header
            # We'll retrieve these in handle_state_change
            self._doctor_result_mic_ok = result.mic_ok
            self._doctor_result_model_ok = result.model_ok
            
            # Post event to UI thread
            self.call_from_thread(self._handle_doctor_completed, doctor_event)
        
        # Run doctor checks asynchronously
        self.doctor_service.run_checks(handle_doctor_result)
    
    def _handle_doctor_completed(self, event: DoctorCompleted) -> None:
        """
        Handle DoctorCompleted event in UI thread.
        
        Called via call_from_thread to ensure UI thread safety.
        Updates header_mic and header_model based on doctor results.
        """
        # Store error information if doctor failed
        if not event.success:
            self.last_error_code = event.error_code or ""
            self.last_error_hint = event.error_hint or ""
        
        # Update header fields based on doctor results
        # These were stored by the doctor callback before calling this method
        if event.success:
            # Success: both should be OK
            self.header_mic = "OK" if self._doctor_result_mic_ok else "FAIL"
            self.header_model = "OK" if self._doctor_result_model_ok else "FAIL"
            self.notify(
                f"‚úÖ Doctor checks passed! Mic: {self.header_mic}, Model: {self.header_model}",
                severity="success",
                timeout=3
            )
        else:
            # Failed: update based on what failed
            self.header_mic = "OK" if self._doctor_result_mic_ok else "FAIL"
            self.header_model = "OK" if self._doctor_result_model_ok else "FAIL"
            error_msg = f"‚ùå Doctor checks failed: {event.error_code or 'Unknown error'}"
            if event.error_hint:
                error_msg += f" - {event.error_hint}"
            self.notify(error_msg, severity="error", timeout=5)
        
        self.logger.info(
            f"Doctor completed: success={event.success}, "
            f"mic={self.header_mic}, model={self.header_model}"
        )
        
        # Initialize STT service if Doctor checks passed (Ticket 8.1)
        if event.success:
            self.logger.info("Starting STT service initialization (Ticket 8.1)")
            self._initialize_stt_service()
        
        # Handle state change (will transition INIT ‚Üí READY or INIT ‚Üí ERROR)
        old_state = self.state_machine.current_state
        self.handle_state_change(event)
        new_state = self.state_machine.current_state
        
        # Notify about state transition
        if old_state != new_state:
            self.notify(
                f"üîÑ State: {old_state} ‚Üí {new_state}",
                severity="information",
                timeout=2
            )
    
    def _initialize_stt_service(self) -> None:
        """
        Initialize STT service asynchronously (Ticket 8.1).
        
        Called after Doctor checks pass successfully.
        Service runs model loading and warmup in background thread.
        """
        def handle_stt_result(result: STTServiceResult) -> None:
            """
            Handle STT service initialization result in UI thread.
            
            This callback is called from the STT thread, so we use
            call_from_thread to safely post events to UI thread.
            """
            if result.success:
                self.logger.info("STT service initialized successfully (Ticket 8.1)")
                self.call_from_thread(
                    self.notify,
                    "‚úÖ STT service ready (model loaded + warmed up)",
                    severity="success",
                    timeout=3
                )
            else:
                error_hint = result.error_hint or "Unknown error"
                self.logger.error(f"STT service initialization failed: {error_hint}")
                self.call_from_thread(
                    self.notify,
                    f"‚ö†Ô∏è STT service init failed: {error_hint}",
                    severity="warning",
                    timeout=5
                )
        
        # Get project root (already calculated in __init__)
        project_root = Path(__file__).parent.parent
        
        # Create and initialize STT service
        self.stt_service = STTService(project_root, self.config)
        self.stt_service.initialize(handle_stt_result)
    
    def _stop_services(self) -> None:
        """Stop background/recording services to free mic and avoid audio buffer buildup."""
        if self.fake_background_service:
            self.fake_background_service.stop()
        if self.snippet_tracker_service:
            self.snippet_tracker_service.stop()
        if self.recording_service:
            self.recording_service.stop()
    
    async def _on_exit_app(self) -> None:
        """Stop services on any exit path (ESC, Ctrl+C, app.exit(), etc.)."""
        self._stop_services()
        await super()._on_exit_app()
    
    def action_quit(self) -> None:
        """Handle Esc key - quit the app"""
        self._stop_services()
        self.exit()
    
    def action_key_f3(self) -> None:
        """
        Handle F3 key press - Start fake background service (Ticket 5.1).
        
        This demonstrates thread-safe communication:
        - Background thread generates fake events
        - UI processes events in UI thread
        - Logs show clear thread separation
        """
        if self.fake_background_service and self.fake_background_service.is_running:
            self.logger.warning("Fake background service already running")
            self.warnings = "Warnungen: Fake Background Service l√§uft bereits"
            return
        
        self.logger.info(
            f"[UI-Thread {self.ui_thread_id}] F3 pressed - Starting fake background service"
        )
        
        # Create callback that uses call_from_thread to safely send message to UI thread
        def send_event_to_ui(message: str, thread_id: int) -> None:
            """Thread-safe callback to send event to UI thread."""
            self.call_from_thread(
                self.post_message,
                FakeBackgroundEvent(message, thread_id)
            )
        
        # Create and start fake background service
        self.fake_background_service = FakeBackgroundService(send_event_to_ui)
        self.fake_background_service.start()
        
        self.warnings = "Warnungen: Fake Background Service gestartet (10 Events)"
    
    def on_fake_background_event(self, event: FakeBackgroundEvent) -> None:
        """
        Handle fake background event in UI thread (Ticket 5.1).
        
        This method is called by Textual when a FakeBackgroundEvent is posted.
        It runs in the UI thread and updates reactive fields.
        """
        current_thread_id = threading.get_native_id()
        
        # Log thread separation for verification
        self.logger.info(
            f"[UI-Thread {current_thread_id}] "
            f"Received fake event from Background-Thread {event.thread_id}: {event.message}"
        )
        self.logger.info(
            f"  ‚Üí Thread-Trennung: UI-Thread ({current_thread_id}) ‚â† "
            f"Background-Thread ({event.thread_id})"
        )
        
        # Update reactive fields (this will trigger watch handlers in UI thread)
        # Primary display in snippet_text (more visible and persistent)
        # Secondary display in warnings (for verification)
        
        if "completed" in event.message.lower():
            # Final event - show completion message
            self.snippet_text = "‚úÖ Fake Background Task abgeschlossen"
            self.snippet_quality = "Alle 10 Events wurden verarbeitet"
            self.warnings = "Warnungen: Task abgeschlossen"
        else:
            # Regular events - extract event number and show prominently
            if "/10" in event.message:
                # Parse event number (e.g., "Fake event 3/10" -> "3")
                parts = event.message.split()
                event_num = "?"
                for part in parts:
                    if "/10" in part:
                        event_num = part.split("/")[0]
                        break
                
                # Show in snippet area (more visible, persists better)
                self.snippet_text = f"üì° Event {event_num}/10 empfangen"
                self.snippet_quality = f"Background-Thread ‚Üí UI-Thread (Ticket 5.1)"
                # Also update warnings for verification
                self.warnings = f"Warnungen: Event {event_num}/10 verarbeitet"
            else:
                # Fallback for other messages
                self.snippet_text = f"üì° {event.message}"
                self.warnings = f"Warnungen: {event.message}"
    
    def _post_level(self, level: float) -> None:
        """Post mic level to UI thread (called via call_from_thread from recording callback)."""
        self.post_message(MicLevelUpdated(level))

    def on_mic_level_updated(self, event: MicLevelUpdated) -> None:
        """Update level_bar from real mic RMS (‚â§10 Hz)."""
        filled = int(event.level * 10)
        filled = max(0, min(10, filled))
        self.level_bar = f"Pegel: [{'‚ñ†' * filled}{'‚ñ°' * (10 - filled)}]"

    def on_snippet_ready_message(self, message: SnippetReadyMessage) -> None:
        """
        Handle snippet ready event in UI thread (Ticket 7.1 & 8.2).
        
        This method is called by Textual when a SnippetReadyMessage is posted.
        It runs in the UI thread and updates the snippet_text and snippet_quality reactive fields.
        
        Ticket 8.2: Handles errors with red ampel + hint.
        """
        current_thread_id = threading.get_native_id()
        
        # Log thread separation for verification
        self.logger.info(
            f"[UI-Thread {current_thread_id}] "
            f"Received snippet from Background-Thread {message.thread_id}"
        )
        self.logger.info(
            f"  ‚Üí Thread-Trennung: UI-Thread ({current_thread_id}) ‚â† "
            f"Background-Thread ({message.thread_id})"
        )
        
        # Check for error (Ticket 8.2)
        if message.error_hint:
            self.logger.error(
                f"  ‚Üí Snippet STT error: {message.error_hint}"
            )
            # Display error with red ampel + hint
            error_display = f"‚ö†Ô∏è Snippet STT Fehler\n\nüî¥ {message.error_hint}"
            self.snippet_text = error_display
            self.snippet_quality = "üî¥ Qualit√§t: Fehler"
            
            # Also show in warnings area
            self.warnings = f"Warnungen: Snippet STT Fehler ({message.error_hint})"
            
            self.logger.info("Snippet error displayed in UI (Ticket 8.2)")
        else:
            # Success path
            self.logger.info(f"  ‚Üí Snippet text: {message.snippet_text[:50]}...")
            self.logger.info(f"  ‚Üí Snippet quality: {message.quality}")
            
            # Combine snippet text and quality into single display (Ticket 7.1 workaround)
            combined_text = f"{message.snippet_text}\n\n{message.quality}"
            
            # Update reactive fields (triggers watch handlers in UI thread)
            self.snippet_text = combined_text
            self.snippet_quality = message.quality  # Keep for potential future use
            
            # Log successful update
            self.logger.info("Snippet displayed in UI (Early Snippet after ~8s cumulative recording)")
    
    # Keybinding action methods (Ticket 4.1)
    
    def action_key_f9(self) -> None:
        """
        Handle F9 key press - Record/Pause/Resume or start new dictation.
        
        Allowed in: READY, RECORDING, PAUSED, DONE
        """
        current_state = self.state_machine.current_state
        allowed_states = {AppState.READY, AppState.RECORDING, AppState.PAUSED, AppState.DONE}
        
        if current_state in allowed_states:
            event = KeyF9Pressed()
            self.handle_state_change(event)
        else:
            self.logger.warning(
                f"F9 pressed in invalid state {current_state}. Allowed states: {allowed_states}"
            )
    
    def action_key_f10(self) -> None:
        """
        Handle F10 key press - Stop recording and start Full-STT.
        
        Allowed in: RECORDING, PAUSED
        """
        current_state = self.state_machine.current_state
        allowed_states = {AppState.RECORDING, AppState.PAUSED}
        
        if current_state in allowed_states:
            event = KeyF10Pressed()
            self.handle_state_change(event)
        else:
            self.logger.warning(
                f"F10 pressed in invalid state {current_state}. Allowed states: {allowed_states}"
            )
    
    def action_key_f6(self) -> None:
        """
        Handle F6 key press - Copy transcript to clipboard.
        
        Allowed in: DONE
        """
        current_state = self.state_machine.current_state
        
        if current_state == AppState.DONE:
            # Get transcript text
            transcript = self.transcript_text
            
            # Skip if transcript is not available or empty
            if transcript == "(noch nicht verf√ºgbar)" or not transcript.strip():
                self.logger.warning("F6 pressed but transcript is not available")
                self.warnings = "Warnungen: Transkript nicht verf√ºgbar"
                return
            
            # Copy to clipboard using Windows clip.exe
            try:
                subprocess.run(
                    ["clip"],
                    input=transcript,
                    text=True,
                    check=True
                )
                self.logger.info("Transcript copied to clipboard successfully")
                # Show brief confirmation
                self.warnings = "Warnungen: Transkript in Zwischenablage kopiert"
            except subprocess.CalledProcessError as e:
                self.logger.error(f"Failed to copy transcript to clipboard: {e}")
                self.warnings = "Warnungen: Fehler beim Kopieren in Zwischenablage"
            except Exception as e:
                self.logger.error(f"Unexpected error copying to clipboard: {e}")
                self.warnings = "Warnungen: Fehler beim Kopieren in Zwischenablage"
        else:
            self.logger.warning(
                f"F6 pressed in invalid state {current_state}. Allowed state: DONE"
            )
    
    def action_key_f8(self) -> None:
        """
        Handle F8 key press - Redo with better model.
        
        Allowed in: DONE
        """
        current_state = self.state_machine.current_state
        
        if current_state == AppState.DONE:
            event = KeyF8Pressed()
            self.handle_state_change(event)
        else:
            self.logger.warning(
                f"F8 pressed in invalid state {current_state}. Allowed state: DONE"
            )
    
    def action_key_f2(self) -> None:
        """
        Handle F2 key press - Doctor/Preflight check.
        
        Allowed in: READY, DONE, ERROR
        In RECORDING/PAUSED/PROCESSING: No-Op + hint
        """
        current_state = self.state_machine.current_state
        allowed_states = {AppState.READY, AppState.DONE, AppState.ERROR}
        invalid_states_with_hint = {AppState.RECORDING, AppState.PAUSED, AppState.PROCESSING}
        
        if current_state in allowed_states:
            event = KeyF2Pressed()
            # Transition to INIT state
            new_state = self.state_machine.transition(event)
            if new_state is not None:
                self._update_reactive_fields_from_state(new_state, current_state)
                self.logger.info(f"State changed from {current_state} to {new_state}, running doctor checks")
                self.notify("üîç Doctor checks starting (F2)...", severity="information", timeout=2)
                # Run doctor checks after transitioning to INIT
                self._run_doctor_checks()
            else:
                self.logger.warning(f"Invalid transition blocked for F2 from {current_state}")
        elif current_state in invalid_states_with_hint:
            # No-Op + show user-visible hint
            self.logger.warning(
                f"F2 pressed in invalid state {current_state}. "
                f"Doctor/Preflight not available during recording/processing."
            )
            self.warnings = "Warnungen: Doctor/Preflight nicht verf√ºgbar w√§hrend Aufnahme/Verarbeitung"
        else:
            # Other invalid states (e.g., INIT) - just log
            self.logger.warning(
                f"F2 pressed in invalid state {current_state}. Allowed states: {allowed_states}"
            )
    
    # Watch-Handler f√ºr reactive Felder (UNIFIED.md 6.1)
    # Textual ruft automatisch watch_<attribute_name> auf wenn reactive Felder sich √§ndern
    # Widgets werden √ºber query_one() aktualisiert, keine gespeicherten Referenzen
    
    def _update_header_status(self) -> None:
        """Update the header status line with current state, mic, and model info."""
        try:
            widget = self.query_one("#header_status", Static)
            if widget.is_mounted:
                # Build full header status line
                state_display = self._format_state_display(self.app_state)
                header_text = f"STT-Diktat-Agent | {state_display} | Mic: {self.header_mic} | Model: {self.header_model}"
                widget.update(header_text)
                widget.refresh()  # Force re-render
                self.logger.debug(f"[UI-Thread] Updated header_status: {header_text}")
        except Exception as e:
            self.logger.warning(f"Failed to update header_status: {e}")
    
    def _sync_status_line(self) -> None:
        """Write current status_recording and status_transcript into #status_line. Called from on_mount because reactive watches from __init__ run before the screen is on the stack and fail; on_mount self-assignment does not re-trigger (same value)."""
        try:
            widget = self.query_one("#status_line", Static)
            if widget.is_mounted:
                status_text = f"Aufnahme: {self.status_recording} | Transkript: {self.status_transcript}"
                widget.update(status_text)
                widget.refresh()
        except Exception as e:
            self.logger.warning(f"Failed to sync status_line: {e}")
    
    def watch_app_state(self, app_state: str) -> None:
        """Update header when app_state changes."""
        self._update_header_status()
    
    def watch_header_mic(self, header_mic: str) -> None:
        """Update header when header_mic changes."""
        self._update_header_status()
    
    def watch_header_model(self, header_model: str) -> None:
        """Update header when header_model changes."""
        self._update_header_status()
    
    def watch_status_recording(self, status_recording: str) -> None:
        """Update status line when status_recording changes."""
        try:
            widget = self.query_one("#status_line", Static)
            if widget.is_mounted:
                status_text = f"Aufnahme: {status_recording} | Transkript: {self.status_transcript}"
                widget.update(status_text)
                widget.refresh()
                self.logger.debug(f"[UI-Thread] Updated #status_line: widget.is_mounted == True")
            else:
                self.logger.warning(f"[UI-Thread] Widget #status_line not mounted, update skipped")
        except Exception as e:
            self.logger.warning(f"Failed to update status_line: {e}")
    
    def watch_status_transcript(self, status_transcript: str) -> None:
        """Update status line when status_transcript changes."""
        try:
            widget = self.query_one("#status_line", Static)
            if widget.is_mounted:
                status_text = f"Aufnahme: {self.status_recording} | Transkript: {status_transcript}"
                widget.update(status_text)
                widget.refresh()
                self.logger.debug(f"[UI-Thread] Updated #status_line: widget.is_mounted == True")
            else:
                self.logger.warning(f"[UI-Thread] Widget #status_line not mounted, update skipped")
        except Exception as e:
            self.logger.warning(f"Failed to update status_line: {e}")
    
    def watch_level_bar(self, level_bar: str) -> None:
        """Update level bar widget when level_bar changes."""
        try:
            widget = self.query_one("#level_bar", Static)
            if widget.is_mounted:
                widget.update(level_bar)
                # Log verification as required by DoD (Ticket 5.2)
                self.logger.debug(f"[UI-Thread] Updated #level_bar: widget.is_mounted == True")
            else:
                self.logger.warning(f"[UI-Thread] Widget #level_bar not mounted, update skipped")
        except Exception as e:
            self.logger.warning(f"Failed to update level_bar: {e}")
    
    def watch_warnings(self, warnings: str) -> None:
        """Update warnings widget when warnings changes."""
        try:
            widget = self.query_one("#warnings", Static)
            if widget.is_mounted:
                widget.update(warnings)
                # Log verification as required by DoD (Ticket 5.2)
                self.logger.debug(f"[UI-Thread] Updated #warnings: widget.is_mounted == True")
            else:
                self.logger.warning(f"[UI-Thread] Widget #warnings not mounted, update skipped")
        except Exception as e:
            self.logger.warning(f"Failed to update warnings: {e}", exc_info=True)
    
    def watch_snippet_text(self, snippet_text: str) -> None:
        """Update snippet text widget when snippet_text changes."""
        try:
            widget = self.query_one("#snippet_text", Static)
            if widget.is_mounted:
                widget.update(snippet_text)
                # Log verification as required by DoD (Ticket 5.2)
                self.logger.debug(f"[UI-Thread] Updated #snippet_text: widget.is_mounted == True")
            else:
                self.logger.warning(f"[UI-Thread] Widget #snippet_text not mounted, update skipped")
        except Exception as e:
            self.logger.warning(f"Failed to update snippet_text: {e}")
    
    def watch_snippet_quality(self, snippet_quality: str) -> None:
        """Update snippet quality widget when snippet_quality changes."""
        try:
            widget = self.query_one("#snippet_quality", Static)
            if widget.is_mounted:
                widget.update(snippet_quality)
                # Log verification as required by DoD (Ticket 5.2)
                self.logger.debug(f"[UI-Thread] Updated #snippet_quality: widget.is_mounted == True")
            else:
                self.logger.warning(f"[UI-Thread] Widget #snippet_quality not mounted, update skipped")
        except Exception as e:
            self.logger.warning(f"Failed to update snippet_quality: {e}")
    
    def watch_transcript_text(self, transcript_text: str) -> None:
        """Update transcript box widget when transcript_text changes."""
        try:
            widget = self.query_one("#transcript_box", Static)
            if widget.is_mounted:
                widget.update(transcript_text)
                # Log verification as required by DoD (Ticket 5.2)
                self.logger.debug(f"[UI-Thread] Updated #transcript_box: widget.is_mounted == True")
            else:
                self.logger.warning(f"[UI-Thread] Widget #transcript_box not mounted, update skipped")
        except Exception as e:
            self.logger.warning(f"Failed to update transcript_box: {e}")
    
    # Helper-Methoden
    
    def _format_state_display(self, state: str) -> str:
        """Format state for header display."""
        # Special case for INIT: show "DOCTOR‚Ä¶ ‚è≥" instead of "INIT ‚è≥"
        if state == "INIT":
            return "DOCTOR‚Ä¶ ‚è≥"
        
        state_icons = {
            "READY": "‚úÖ",
            "RECORDING": "‚è∫",
            "PAUSED": "‚è∏",
            "PROCESSING": "‚è≥",
            "DONE": "‚úÖ",
            "ERROR": "‚ùå",
        }
        icon = state_icons.get(state, "?")
        return f"{state} {icon}"
    
    def _update_reactive_fields_from_state(self, state: AppState, old_state: AppState) -> None:
        """
        Update reactive fields based on current state.
        
        Mapping gem√§√ü UNIFIED.md 6.2 und Plan:
        - app_state: direkt aus StateMachine
        - status_recording: "AUS" (READY/DONE/ERROR), "EIN" (RECORDING), "PAUSE" (PAUSED), "‚Äî" (PROCESSING)
        - status_transcript: "‚Äî" (au√üer DONE), "verf√ºgbar" (DONE)
        
        Args:
            state: New state
            old_state: Previous state (for detecting transitions like DONE -> RECORDING)
        """
        state_str = state.value
        
        # Update app_state
        self.app_state = state_str
        
        # Map state to status_recording
        if state == AppState.READY or state == AppState.DONE or state == AppState.ERROR:
            self.status_recording = "AUS"
            self.level_bar = "Pegel: [          ]"
            # Stop snippet tracker when leaving RECORDING/PAUSED (Ticket 7.1)
            if self.snippet_tracker_service:
                self.logger.info("Stopping SnippetTrackerService (state: not RECORDING/PAUSED)")
                self.snippet_tracker_service.stop()
            
            # Display error information if in ERROR state
            if state == AppState.ERROR and self.last_error_code:
                error_display = f"Fehler: {self.last_error_code}"
                if self.last_error_hint:
                    error_display += f" - {self.last_error_hint}"
                self.warnings = f"Warnungen: {error_display}"
        elif state == AppState.RECORDING:
            self.status_recording = "EIN"
            self.level_bar = "Pegel: [          ]"
            # Reset transcript and snippet when starting new dictation (DONE -> RECORDING)
            # UNIFIED.md 5.3: DONE --F9--> RECORDING (Start new dictation; clears transcript UI + resets snippet state)
            if old_state == AppState.DONE:
                self.transcript_text = "(noch nicht verf√ºgbar)"
                self.snippet_text = "(leer)"
                self.snippet_quality = "‚Äî"
            # Start or resume recording (real mic) and snippet tracker when entering RECORDING
            if old_state == AppState.PAUSED:
                # Resuming from pause
                if self.recording_service:
                    self.recording_service.resume()
                if self.snippet_tracker_service:
                    self.logger.info("Resuming SnippetTrackerService (state: RECORDING from PAUSED)")
                    self.snippet_tracker_service.resume()
            else:
                # New recording: start RecordingService (with real level meter) and SnippetTracker
                def _on_mic_level(level: float) -> None:
                    self.call_from_thread(self._post_level, level)
                self.recording_service = RecordingService(self.config, level_callback=_on_mic_level)
                self.recording_service.start()
                self.logger.info("Starting SnippetTrackerService (state: RECORDING, Ticket 8.2)")
                def send_snippet_to_ui(
                    snippet_text: str,
                    quality: str,
                    thread_id: int,
                    error_hint: Optional[str] = None
                ) -> None:
                    self.call_from_thread(
                        self.post_message,
                        SnippetReadyMessage(snippet_text, quality, thread_id, error_hint)
                    )
                def get_audio_for_snippet() -> Optional[np.ndarray]:
                    return self.recording_service.get_snippet(self.config.snippet.seconds) if self.recording_service else None
                snippet_threshold = float(self.config.snippet.seconds)
                self.snippet_tracker_service = SnippetTrackerService(
                    send_snippet_to_ui,
                    stt_service=self.stt_service,
                    threshold_seconds=snippet_threshold,
                    get_audio_for_snippet=get_audio_for_snippet,
                )
                self.snippet_tracker_service.start()
        elif state == AppState.PAUSED:
            self.status_recording = "PAUSE"
            # Pause recording (real mic)
            if self.recording_service:
                self.recording_service.pause()
            # Pause snippet tracker when paused (Ticket 7.1)
            if self.snippet_tracker_service:
                self.logger.info("Pausing SnippetTrackerService (state: PAUSED)")
                self.snippet_tracker_service.pause()
        elif state == AppState.PROCESSING:
            self.status_recording = "‚Äî"
            # Duration for Full-STT (Ticket 8.3): read before stopping SnippetTracker
            if self.snippet_tracker_service and self.snippet_tracker_service.is_running:
                duration_sec = max(1.0, self.snippet_tracker_service.cumulative_time)
            else:
                duration_sec = 10.0 if old_state == AppState.DONE else 1.0
            # Get full recording from mic before stopping
            full_audio: Optional[np.ndarray] = None
            if self.recording_service:
                full_audio = self.recording_service.get_full()
                self.recording_service.stop()
            # Stop snippet tracker when processing (Ticket 7.1)
            if self.snippet_tracker_service:
                self.logger.info("Stopping SnippetTrackerService (state: PROCESSING)")
                self.snippet_tracker_service.stop()
            # Start Full-STT worker (Ticket 8.3)
            self._start_full_stt(duration_sec, full_audio)
        elif state == AppState.INIT:
            self.status_recording = "‚Äî"
        
        # Map state to status_transcript
        if state == AppState.DONE:
            self.status_transcript = "verf√ºgbar"
        else:
            self.status_transcript = "‚Äî"
    
    def _start_full_stt(self, duration_sec: float, audio_data: Optional[np.ndarray] = None) -> None:
        """
        Start Full-STT worker (Ticket 8.3).
        
        Called when entering PROCESSING. Uses real mic audio when available,
        else synthetic; F8 from DONE uses 10s placeholder.
        """
        job_id = f"job_{int(time.time() * 1000)}"
        if not self.stt_service or not self.stt_service.is_ready():
            self.handle_state_change(
                FullSTTFail(
                    error_code="STT_NOT_READY",
                    error_hint="STT nicht bereit",
                    job_id=job_id,
                )
            )
            return
        if audio_data is not None and len(audio_data) > 0:
            audio_data = audio_data.astype(np.float32, copy=False) if audio_data.dtype != np.float32 else audio_data
        else:
            num_samples = int(duration_sec * 16000)
            audio = np.random.normal(0, 0.1, num_samples).astype(np.float32)
            envelope = np.sin(np.linspace(0, 10 * np.pi, num_samples)) * 0.5 + 0.5
            audio_data = (audio * envelope.astype(np.float32))
        
        def on_result(result: FullTranscriptionResult) -> None:
            self.call_from_thread(self._handle_full_stt_result, result)
        self.stt_service.transcribe_full(audio_data, job_id, on_result)
    
    def _handle_full_stt_result(self, result: FullTranscriptionResult) -> None:
        """
        Handle Full-STT result in UI thread (Ticket 8.3).
        
        Builds FullSTTDone or FullSTTFail and calls handle_state_change.
        """
        if result.success:
            ev = FullSTTDone(
                transcript=result.transcript or "",
                job_id=result.job_id,
            )
        else:
            ev = FullSTTFail(
                error_code=result.error_code or "UNKNOWN",
                error_hint=result.error_hint or "Unbekannter Fehler",
                job_id=result.job_id,
            )
        self.handle_state_change(ev)
    
    def handle_state_change(self, event: AppEvent) -> None:
        """
        Handle state change event.
        
        Called when an event should trigger a state transition.
        Updates reactive fields based on new state.
        For FullSTTDone/FullSTTFail, sets transcript_text or last_error_* before
        _update_reactive_fields (Ticket 8.3).
        """
        old_state = self.state_machine.current_state
        new_state = self.state_machine.transition(event)
        if new_state is not None:
            if isinstance(event, FullSTTDone):
                # Empty transcript: show explanation; use ASCII hyphen for clipboard (avoids encoding issues).
                self.transcript_text = event.transcript if (event.transcript and event.transcript.strip()) else "(leer - Platzhalter-Audio)"
            elif isinstance(event, FullSTTFail):
                self.last_error_code = event.error_code
                self.last_error_hint = event.error_hint
            self._update_reactive_fields_from_state(new_state, old_state)
            self.logger.info(f"State changed from {old_state} to {new_state}, reactive fields updated")
        else:
            self.logger.warning(f"Invalid transition blocked for event {type(event).__name__}")
